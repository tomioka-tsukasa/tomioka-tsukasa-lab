# 第2章 シェーダーでのランダム関数

ジェネラティブデザイン - https://thebookofshaders.com/10/?lan=jp

## シェーダーでのランダム生成の挑戦

### なぜシェーダーでランダムが難しいのか？

シェーダーには通常のプログラミング言語にある`random()`関数が**ありません**。

理由：
- **GPU並列処理**: 何千ものピクセルが同時に計算される
- **決定性が必要**: 同じ入力で毎回同じ結果が必要
- **高速性重視**: 複雑な乱数生成は避けたい

### The Book of Shadersのアプローチ

The Book of Shadersでは、**サイン関数**を使った巧妙な方法でランダムを生成します。

## 基本的なランダム関数（1D）

```glsl
float random(float x) {
    return fract(sin(x * 12.9898) * 43758.5453);
}
```

### この関数の仕組みを詳しく解説

#### ステップ1: 入力値を拡大
```glsl
x * 12.9898
```
- 入力値`x`に大きな係数`12.9898`を掛ける
- この数値は経験的に良い結果を生むことが知られている
- 入力の小さな変化が大きな変化を生む

#### ステップ2: サイン関数を適用
```glsl
sin(x * 12.9898)
```
- サイン関数は-1から1の間の値を返す
- 周期的な関数だが、大きな係数により周期が見えにくくなる
- 滑らかな変化を作り出す

#### ステップ3: 結果をさらに拡大
```glsl
sin(x * 12.9898) * 43758.5453
```
- サイン関数の結果に別の大きな数`43758.5453`を掛ける
- 小数点部分をより「ランダム」にする
- この数値も経験的に選ばれた値

#### ステップ4: 小数点部分のみを取得
```glsl
fract(sin(x * 12.9898) * 43758.5453)
```
- `fract()`関数は小数点部分のみを返す
- 例：`fract(3.14159)` → `0.14159`
- 0から1の範囲の値になる
- 整数部分は捨てられる

### なぜこの方法が有効なのか？

1. **非線形変換**: サイン関数により入力が非線形に変換される
2. **高周波成分**: 大きな係数により細かい変化が生まれる
3. **正規化**: `fract()`により常に0〜1の範囲に収まる
4. **決定性**: 同じ入力には必ず同じ出力が返る
5. **高速**: GPUで高速に計算できる

### この関数の限界

1. **周期性**: 非常に長いが、いずれは繰り返す
2. **品質**: 統計的には完璧ではない
3. **分布の偏り**: 完全に均等ではない場合がある
4. **予測可能性**: 数学的には予測可能

### 実際の使用例

```glsl
// 入力値0.5でのランダム値生成
float input = 0.5;
float output = random(input);
// output ≈ 0.374 (常に同じ値)

// 異なる入力での結果
random(0.0) ≈ 0.000
random(0.1) ≈ 0.374
random(0.2) ≈ 0.891
random(0.3) ≈ 0.729
```

### マジックナンバーについて

- `12.9898`と`78.233`（後で使用）は経験的に選ばれた値
- これらの数値は**素数の性質**を活用している
- 異なる値でも動作するが、品質が変わる可能性がある
- The Book of Shadersコミュニティで広く使われている標準値

次の章では、この1Dランダム関数を実際にシェーダーで使用して、様々なパターンを作成します。